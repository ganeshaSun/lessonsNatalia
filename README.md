# Первый урок

При выкачивании нвого проекта всегда ищи readme - вдруг твой предшественник на проекте оставил тут ценные указания.

Теперь урок. Будем повторять базу Java. При выполнении ДЗ можно и нужно гуглить. Весь код сопровождай комментариями,
типа "//Юра, вот тут ты можешь увидеть пример перегрузки".

1) Наследование + инкапсуляция: создай класс-родитель. Унаследуй от него потомка. Создай внутри родителя три метода с
   различными областями видимости. Покажи, что методы, доступные потомку, действительно можно в нем вызвать, и как
   методы потомка, и как методы ВНУТРИ собственных методов потомка.

2) Полиморфизм на примере переопределения и перегрузки. Создай класс с конструктором и произвольным методом. Перегрузи
   конструктор и метод в рамках класса, что б было 3 конструктора и 3 метода. Унаследуйся от класса. Покажи, что в
   потомке ты можешь переопределять методы. А как вызвать конструктор родителя в потомке (т.е. конструктор суперкласса?)

3) Полиморфизм на примере интерфейсов. Создай интерфейс для будущего класса (например - ITSpecialist, методы типа
   сказать имя и делать работу). Создай трех ITSpecialists, которые имплементят этот интерфейс - программиста,
   тестировщика и бизнес-аналитика. У каждого из них должно быть имя и быть разная реализация метода делать работу. В
   рамках main обратись к ним, как к объектам интерфейса ITSpecialist, но что б результат выполнения работы был разный.

4) Создай абстрактный класс. Можно ли создать экземпляр астрактного класса?

5) Создай класс, от которого нельзя унаследоваться. Погугли, как запретить наследование.

6) Создай класс, который содержит пару статических методов. В рамках main вызови эти статические методы. Нужно ли
   создавать экземпляр класса для вызова статического метода?

7) В предыдущем классе из пункта 6 создай блок статической инициализации вида static { <тут что-то> }. Когда он будет
   выполнен? Покажи в main.

8) Раз создали класс с блоком статической инициализации, создай класс с блоком НЕстатической инициализации вида { <тут
   что-то> }. Когда он будет выполнен? Покажи в main.

9) Создай массив из 3 элементов. Какой индекс имеет первый элемент массива? Размести в массиве 3 разных ITSpecialist в
   доступных элементах. Что произойдет, если попробуешь добавить четвертого? Что нужно сделать, чтобы программа
   продолжила выполняться после попытки добавить четвертого?

10) Циклом пройдись по массиву и распечатай имена добавленных специалистов

11) Создай три любых реализации интерфейса List на твой выбор. Но одна из них должна быть ArrayList=) В каждую положи
    трех специалистов. Пройдись по каждому из них циклами (для разнообразия не используй цикл из 10го пункта, почитай,
    какие есть циклы в Java) и распечатай имена специалистов.

12) Создай HashMap опять-таки из трех специалистов, где ключ - имя специалиста, а значение - сам объект-специалист.
    Циклом пройдись по HashMap и распечатай текст, включающий в себя имя спеца и работу, которую он делает (т.е. текст
    включает в себя и значение ключа, и результат выполнения работы). А можно положить в HashMap специалистов с
    одинаковым именем? А почему?* (это вопрос со звездочкой=)

В результате получим довольно-таки длинный main c комментариями. Также я ожидаю комментарии в рамках каждого из классов.
Структуру пакетов можешь делать произвольную (кстати, какой модификатор доступа ты не сможешь продемострировать, если
все лежит в одном пакете?)

# Второй урок

Для удобства, давай добавим в наш проект JUnit и попробуем каждый пункт делать отдельным тестом. Для раздельного
запуска, дебага и ревью=)
Добавить 4й JUnit проще, 5й - прогрессивнее.

Перед заданием, почитай про отличия примитивных и ссылочных типов в Java.

1) Создай два одинаковых (маленьких) int. Сравни через ==. Что вернулось результатом сравнения? Почему? Можно ли вызвать
   у них hashcode и equals?

Создай два одинаковых (больших) Integer. Сравни через ==. Что вернулось результатом сравнения? Почему? Можно ли вызвать
у них hashcode и equals?

Сделай так, чтобы один из Integer создавался через ключевое слово new. Сравни через ==. Что вернулось результатом
сравнения? Почему?

2) Проведи сравнение через ==, .hashcode(), .equals двух одинаковых String. Объясни каментом, почему в том или ином
   случае вернулось true или false. Что будет, если обе строки были созданы, как = ""? Что будет, если одна из них
   создавалась с использованием ключевого слова new? Что будет, если обе из них создавали с использованием ключевого
   слова new?

Тут есть нюансы, можно почитать что-то типа https://javarush.ru/groups/posts/equals-java-sravnenie-strok

3) Сделай самописный класс Laptop. Пусть у него будут поля brand, frequency (например, 3000), memory (например, 16).
   Создай два идентичных лаптопа.  
   Проведи сравнение через ==, .hashcode(), .equals. Объясни каментом, почему в том или ином случае вернулось true или
   false.

Теперь мы решили, что считаем лэптопы равными друг другу, если у них совпадает частота и количество гигов оперативки.
Переопредели внутри самописного класса equals так, чтобы он проводил сравнение только по этим полям, игнорируя
производителя.

4) Таки нам надо разобраться с хэшмапой (надеюсь, про хэшкод ты уже читала-перечитала). Вернемся к примеру из прошлого
   занятия, когда у тебя есть самописный класс с единственным полем String имя. Создай три экземпляра такого класса,
   используй разные имена. Создай хэшмапу, где ключ - имя, значение - сам объект. Положи все три экземпляра в эту
   хэшмапу. Сколько после этого внутри хэшмапы пар? Почему произошло то, что произошло?
   ===========================================================================

5) Напиши произвольный тест, в котором происходит выброс проверяемого исключения, например, тот же
   ArrayIndexOutOfBoundsException. Прокинь его в сигнатуру метода.

6) Скопипасти предыдущий тест. Теперь пусть экспешен перехватывается try/catch.

7) Скопипасти предыдущий тест. Теперь пусть экспешен перехватывается try/catch, но catch ожидает эксепшен другого типа.
   К чему это приводит?

8) Скопипасти предыдущий тест. Теперь пусть экспешен перехватывается try/catch, но catch ожидает эксепшен-родителя, т.е.
   базовый Exception. К чему это приводит?

9) Почитай про finally. Напиши тест, в котором finally выполняется.

10) А теперь напиши тест, в котором finally не выполняется (возможно, таких тестов можно изобрести больше, чем один).

# Третий урок

Самостоятельное изучения лямбда выражений и Stream API

# Четвертый урок

Перед уроком на почту учащемуся высылаются также данные для авторизации на энвайроменте.

Урок представляет собой изучение инструмента Rest Assured и написание бэкэнд тестов на Risk Market.

Депенденси https://mvnrepository.com/artifact/io.rest-assured/rest-assured/4.3.2
Туториал https://www.baeldung.com/rest-assured-tutorial
Работа с параметрами в RestAssured https://www.baeldung.com/rest-assured-header-cookie-parameter

1. Напиши простой тест, который бы обращался к google.com и убеждался, что статус код 200

2. Теперь займемся тестированием RiskMarket API. DEV: https://dev.riskmarket.tech/gateway/swagger-ui.html#/
   Нас будут интересовать подсказки hints!
   Создать подсказку: https://dev.riskmarket.tech/gateway/catalogue/hint/admin
   Получить подсказку: https://dev.riskmarket.tech/gateway/catalogue/hint/admin/{hintId}

Пример создания подсказки: POST https://dev.riskmarket.tech/gateway/catalogue/hint/admin
{"action":"NONE","active":true,"countries":["AUSTRALIA"],"insuranceTypes":["TRAVEL"],"text":"тест на пост"}

Пользователи:
АДМИН (он может создавать подсказки)
!!!логин и пароль в почте!!!

Рядовой ПОЛЬЗОВАТЕЛЬ (а он не может)
!!!логин и пароль в почте!!!

Авторизация на дев окружении https://dev.riskmarket.tech/gateway/user-service/oauth/token?remember-me=true

3. Мы НЕ можем хранить хранить креденшиалы админа и пользователя в проекте, это не секьюрно. Нам поможет файл
   application.properties, который добавлен в .gitignore и хранится только на твоем компьютере. Соответственно, нужно
   написать класс-считываетель пропертей из этого файла. Создай файл application.properties внутри пакаджа
   java/resources. Добавь в него четыре переменных (имя админа, пароль админа, имя пользователя, пароль пользователя).
   Напиши класс, считывающий их оттуда и устанавливающий в переменные класс в рантайме. Пример класса (там разве что
   название файла пропертей другое) -
   https://crunchify.com/java-properties-file-how-to-read-config-properties-values-in-java/ Убедись, что они оттуда
   считываются.

4. В начале авторизуемся, как АДМИН. К запросу авторизации нужно приделать два хедера x-xsrf-token: null_csrf
   Content-Type: application/x-www-form-urlencoded и данные формы grant_type: password username: <админ>
   password: <админский>
   В ответе убедись, что получил статус код 200 и сохрани в переменные (подсказка - доступ к ним через getCookies()):
   значение XSRF-TOKEN значение CLIENT-ID значение authObject

5. Теперь сделай POST на создание подсказки. Тело подсказки, например:
   {
   "text": "text of the hint 2020",
   "active": "true",
   "insuranceTypes": [
   ],
   "action": "NONE",
   "countries": [
   "RUSSIA"
   ]
   } Можешь передавать текст в боди, как строку, но лучше всего вынеси JSON в отдельный файл, погугли, как его считать
   из файла, и уже потом передавай внутрь соответствующего метода RestAssured. Не забудь в хедеры реквеста добавить
   Content-Type: application/json, x-xsrf-token, CLIENT-ID, authObject со значениями!
   В ответе убедить, что статус код 200 и сохрани айдишник свежесозданной подсказки в переменную.

6. Теперь сделай GET на созданную подсказку. Убедись, что статус код 200 и вернулась именно твоя подсказка
   (лучше делай не тупо equals всей стринги, а попарси JSON по каждому полю, в жизни пригодится... Если хочешь,
   используй более сложный текст подсказки).

7. А теперь в следующем тесте авторизуйся, как рядовой ПОЛЬЗОВАТЕЛЬ. Убедись, что у него нет возможности создать
   подсказку через POST!

8. Проверь, может ли рядовой ПОЛЬЗОВАТЕЛЬ загетать подсказку, созданную администратором? А не авторизованный (т.е. без
   передачи токена, айдишника клиента и authObject)?

9. Создай BaseTest, от которого унаследуй свой тестовый класс, созданный ранее.
   Почитав https://www.baeldung.com/rest-assured-tutorial вынеси туда установку RestAssured.baseURI, а может быть, и
   что-то еще (например, считывание из файла, а может, и процесс авторизации)

10. В BaseTest создай спецификацию для (позитивного) ответа, вынеси туда проверку статус кода 200. Зарефактори тесты,
    чтобы они использовали спецификацию. Про спецификации можно почитать https://habr.com/ru/post/421005/

11. Кстати, методы считывания из файлов не имеют отношения к тестам и RestAssured! Давай переложим их из пакаджа test в
    пакадж java, т.к. следуя best practices у нас должно быть разделение тестовой логики и реализации - т.е. в пакадже
    test непосредственно тесты с какими-то шагами и проверками, а вспомогательные Java-классы (считыватели проперти,
    парсеры, хелперы и т.д.) в пакадже java!

Если по каким-то причинам DEV Риск маркета не работает, у них есть еще train.riskmarket.tech и demo.riskmarket.tech -
там вроде бы все те же пользователи и API.

