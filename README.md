# Первый урок

При выкачивании нвого проекта всегда ищи readme - вдруг твой предшественник на проекте оставил тут ценные указания.

Теперь урок. Будем повторять базу Java.
При выполнении ДЗ можно и нужно гуглить.
Весь код сопровождай комментариями, типа "//Юра, вот тут ты можешь увидеть пример перегрузки".

1) Наследование + инкапсуляция: создай класс-родитель. Унаследуй от него потомка. Создай внутри родителя три метода с различными областями видимости.
Покажи, что методы, доступные потомку, действительно можно в нем вызвать, и как методы потомка, и как методы ВНУТРИ собственных методов потомка.

2) Полиморфизм на примере переопределения и перегрузки. Создай класс с конструктором и произвольным методом. Перегрузи конструктор и метод в рамках класса,
что б было 3 конструктора и 3 метода. Унаследуйся от класса. Покажи, что в потомке ты можешь переопределять методы.
А как вызвать конструктор родителя в потомке (т.е. конструктор суперкласса?)

3) Полиморфизм на примере интерфейсов. Создай интерфейс для будущего класса (например - ITSpecialist, методы типа сказать имя и делать работу).
Создай трех ITSpecialists, которые имплементят этот интерфейс - программиста, тестировщика и бизнес-аналитика.
У каждого из них должно быть имя и быть разная реализация метода делать работу. В рамках main обратись к ним, как к объектам интерфейса ITSpecialist, но что б результат выполнения работы был разный.

4) Создай абстрактный класс. Можно ли создать экземпляр астрактного класса?

5) Создай класс, от которого нельзя унаследоваться. Погугли, как запретить наследование.

6) Создай класс, который содержит пару статических методов. В рамках main вызови эти статические методы.
Нужно ли создавать экземпляр класса для вызова статического метода?

7) В предыдущем классе из пункта 6 создай блок статической инициализации вида static { <тут что-то> }.
Когда он будет выполнен? Покажи в main.

8) Раз создали класс с блоком статической инициализации, создай класс с блоком НЕстатической инициализации вида { <тут что-то> }.
Когда он будет выполнен? Покажи в main.

9) Создай массив из 3 элементов. Какой индекс имеет первый элемент массива? Размести в массиве 3 разных ITSpecialist в доступных элементах.
Что произойдет, если попробуешь добавить четвертого? Что нужно сделать, чтобы программа продолжила выполняться после попытки добавить четвертого?

10) Циклом пройдись по массиву и распечатай имена добавленных специалистов

11) Создай три любых реализации интерфейса List на твой выбор. Но одна из них должна быть ArrayList=) В каждую положи трех специалистов.
Пройдись по каждому из них циклами (для разнообразия не используй цикл из 10го пункта, почитай, какие есть циклы в Java) и распечатай имена специалистов.

12) Создай HashMap опять-таки из трех специалистов, где ключ - имя специалиста, а значение - сам объект-специалист.
Циклом пройдись по HashMap и распечатай текст, включающий в себя имя спеца и работу, которую он делает (т.е. текст включает в себя и значение ключа, и результат выполнения работы).
А можно положить в HashMap специалистов с одинаковым именем?
А почему?* (это вопрос со звездочкой=)

В результате получим довольно-таки длинный main c комментариями. Также я ожидаю комментарии в рамках каждого из классов.
Структуру пакетов можешь делать произвольную (кстати, какой модификатор доступа ты не сможешь продемострировать, если все лежит в одном пакете?)

# Второй урок

Для удобства, давай добавим в наш проект JUnit и попробуем каждый пункт делать отдельным тестом. Для раздельного запуска, дебага и ревью=)
Добавить 4й JUnit проще, 5й - прогрессивнее. 

Перед заданием, почитай про отличия примитивных и ссылочных типов в Java.

1) Создай два одинаковых (маленьких) int. Сравни через ==. Что вернулось результатом сравнения? Почему?
 Можно ли вызвать у них hashcode и equals?  
 
Создай два одинаковых (больших) Integer. Сравни через ==. Что вернулось результатом сравнения? Почему?
Можно ли вызвать у них hashcode и equals?  
 
Сделай так, чтобы один из Integer создавался через ключевое слово new. Сравни через ==. Что вернулось результатом сравнения? Почему?

2) Проведи сравнение через ==, .hashcode(), .equals двух одинаковых String. Объясни каментом, почему в том или ином случае вернулось true или false.
Что будет, если обе строки были созданы, как  = ""? 
Что будет, если одна из них создавалась с использованием ключевого слова new? 
Что будет, если обе из них создавали с использованием ключевого слова new?

Тут есть нюансы, можно почитать что-то типа https://javarush.ru/groups/posts/equals-java-sravnenie-strok

3) Сделай самописный класс Laptop. Пусть у него будут поля brand, frequency (например, 3000), memory (например, 16). Создай два идентичных лаптопа.  
Проведи сравнение через ==, .hashcode(), .equals. Объясни каментом, почему в том или ином случае вернулось true или false.

Теперь мы решили, что считаем лэптопы равными друг другу, если у них совпадает частота и количество гигов оперативки.
Переопредели внутри самописного класса equals так, чтобы он проводил сравнение только по этим полям, игнорируя производителя.

4) Таки нам надо разобраться с хэшмапой (надеюсь, про хэшкод ты уже читала-перечитала).
Вернемся к примеру из прошлого занятия, когда у тебя есть самописный класс с единственным полем String имя.
Создай три экземпляра такого класса, используй разные имена.
Создай хэшмапу, где ключ - имя, значение - сам объект.
Положи все три экземпляра в эту хэшмапу. 
Сколько после этого внутри хэшмапы пар? Почему произошло то, что произошло?
===========================================================================

5) Напиши произвольный тест, в котором происходит выброс проверяемого исключения, например, тот же ArrayIndexOutOfBoundsException.
Прокинь его в сигнатуру метода.

6) Скопипасти предыдущий тест. Теперь пусть экспешен перехватывается try/catch. 

7) Скопипасти предыдущий тест. Теперь пусть экспешен перехватывается try/catch, но catch ожидает эксепшен другого типа. 
К чему это приводит?

8) Скопипасти предыдущий тест. Теперь пусть экспешен перехватывается try/catch, но catch ожидает эксепшен-родителя, т.е. базовый Exception. 
К чему это приводит?
   
9) Почитай про finally. Напиши тест, в котором finally выполняется.

10) А теперь напиши тест, в котором finally не выполняется (возможно, таких тестов можно изобрести больше, чем один).
